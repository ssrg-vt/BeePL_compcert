(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*                  Xavier Leroy, INRIA Paris                          *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(** Translation from Mach to eBPF assembly language *)

Require Archi.
Require Import Coqlib Errors.
Require Import AST Integers Memdata.
Require Import Op Locations Mach Asm.
Require Size.

Local Open Scope string_scope.
Local Open Scope error_monad_scope.

(** The code generation functions take advantage of several
  characteristics of the [Mach] code generated by earlier passes of the
  compiler, mostly that argument and result registers are of the correct
  types.  These properties are true by construction, but it's easier to
  recheck them during code generation and fail if they do not hold. *)

Definition errcode_of_Z (n:Z) : list errcode :=
  match n with
  | Z0 => MSG "0" :: nil
  | Zpos p => POS p :: nil
  | Zneg p => MSG "-" ::POS p :: nil
  end.


(** Extracting integer registers. *)

Definition ireg_of (r: mreg) : res ireg :=
  match preg_of r with
  | IR mr => OK mr
  | FR mr => Error (msg "eBPF does not have floating point registers")
  | _ => Error (msg "Asmgen.ireg_of")
  end.

Definition freg_of (r: mreg) : res freg :=
  match preg_of r with
  | FR mr => OK mr
  | _ => Error (msg "Asmgen.freg_of")
  end.

(** Smart constructors for arithmetic operations. *)

Definition warchib (b:bool) := if b then W64 else W32.

Definition warchi := warchib Archi.ptr64.


Definition addptrofs (rd rs: ireg) (n: ptrofs) (k: code) :=
  if Ptrofs.eq_dec n Ptrofs.zero then
    OK (Palu MOV warchi rd (inl rs) :: k)
  else
  if Size.Ptrofs.is_int n
  then  OK (Palu MOV warchi rd (inl rs) :: Palu ADD warchi rd (inr (Ptrofs.to_int n)) :: k)
  else  Error (MSG "Offset "::(errcode_of_Z (Ptrofs.signed n))++MSG " is not representable"::nil).

Definition get_int (n:int64) :=
  let i := Int64.signed n in
  if Z.leb Int.min_signed i && Z.leb i Int.max_signed
  then OK (Int.repr i)
  else Error ((MSG "Constant ")::(errcode_of_Z (Int64.unsigned n))++ (MSG " is not representable")::nil).

(** Translation of conditional branches. *)

Definition transl_comparison (cmp:comparison) (sg:Ctypes.signedness) :=
  match cmp with
  | Ceq => EQ
  | Cne => NE
  | Clt => LT sg
  | Cle => LE sg
  | Cgt => GT sg
  | Cge => GE sg
  end.

Definition transl_cbranch_signed (cmp: comparison) (w:width) (r1: ireg) (r2: ireg+int) (lbl: label) :=
  Pjmpcmp (transl_comparison cmp Ctypes.Signed) w  r1 r2 lbl.

Definition transl_cbranch_unsigned (cmp: comparison) (w:width) (r1: ireg) (r2: ireg+int) (lbl: label) :=
  Pjmpcmp (transl_comparison cmp Ctypes.Unsigned) w r1 r2 lbl.

Definition transl_cbranch (cond: condition) (args: list mreg) (lbl: label) (k: code) :=
  match cond, args with
  | Ccomp c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cbranch_signed c W32 r1 (inl r2) lbl :: k)

  | Ccompu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cbranch_unsigned c W32 r1 (inl r2) lbl :: k)

  | Ccompimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_cbranch_signed c W32 r1 (inr n) lbl :: k)

  | Ccompuimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_cbranch_unsigned c W32 r1 (inr n) lbl :: k)

  | Ccompl c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cbranch_signed c W64 r1 (inl r2) lbl :: k)

  | Ccomplu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cbranch_unsigned c W64 r1 (inl r2) lbl :: k)

  | Ccomplimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      do n' <- get_int n;
      OK (transl_cbranch_signed c W64 r1 (inr n') lbl :: k)

  | Ccompluimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      do n' <- get_int n;
      OK (transl_cbranch_unsigned c W64 r1 (inr n') lbl :: k)

  | Ccompf _, _
  | Cnotcompf _, _
  | Ccompfs _, _
  | Cnotcompfs _, _ => Error (msg "Floating point comparisons are not available in eBPF")

  | _, _ => Error(msg "Asmgen.transl_cbranch")
  end.

Definition transl_cond_as_Pcmp (cond: comparison) (w:width) (sg:Ctypes.signedness) (rd:ireg) (a:ireg+int)  (k:code) :=
    Pcmp (transl_comparison cond sg) w rd a :: k.


Definition transl_cond_op (cond: condition) (r: mreg) (args: list mreg) (k: code) :=
  match cond, args with
  | Ccomp c, a1 :: a2 :: nil =>
      assertion_str [ "Ccomp" ] (mreg_eq r a1);
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cond_as_Pcmp c W32 Ctypes.Signed r1 (inl r2) k)

  | Ccompu c, a1 :: a2 :: nil =>
      assertion_str [ "Ccompu"] (mreg_eq r a1);
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cond_as_Pcmp c W32 Ctypes.Unsigned r1 (inl r2) k)

  | Ccompimm c n, a1 :: nil =>
      assertion_str [ "Ccompimm" ] (mreg_eq r a1);
      do r1 <- ireg_of a1;
      OK (transl_cond_as_Pcmp c W32 Ctypes.Signed r1 (inr n) k)

  | Ccompuimm c n, a1 :: nil =>
      assertion_str [ "Ccompuimm" ] (mreg_eq r a1);
      do r1 <- ireg_of a1;
      OK (transl_cond_as_Pcmp c W32 Ctypes.Unsigned r1 (inr n) k)

  | Ccompl c, a1 :: a2 :: nil =>
      assertion_str [ "Ccompl" ] (mreg_eq r a1);
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cond_as_Pcmp c W64 Ctypes.Signed r1 (inl r2) k)

  | Ccomplu c, a1 :: a2 :: nil =>
      assertion_str [ "Ccomplu"] (mreg_eq r a1);
      do r1 <- ireg_of a1;
      do r2 <- ireg_of a2;
      OK (transl_cond_as_Pcmp c W64 Ctypes.Unsigned r1 (inl r2) k)

  | Ccomplimm c n, a1 :: nil =>
      assertion_str [ "Ccomplimm" ] (mreg_eq r a1);
do r1 <- ireg_of a1;
do n' <- get_int n;
      OK (transl_cond_as_Pcmp c W64 Ctypes.Signed r1 (inr n') k)

  | Ccompluimm c n, a1 :: nil =>
      assertion_str [ "Ccompluimm" ] (mreg_eq r a1);
do r1 <- ireg_of a1;
do n' <- get_int n;
      OK (transl_cond_as_Pcmp c W64 Ctypes.Unsigned r1 (inr n') k)

  | Ccompf c, _
  | Cnotcompf c, _
  | Ccompfs c, _
  | Cnotcompfs c, _ => Error (msg "Floating point comparisons are not available in eBPF")

  | _, _ => Error (msg "Asmgen.transl_cond_op")
  end.

(** Translation of the arithmetic operation [r <- op(args)].
  The corresponding instructions are prepended to [k]. *)

Definition transl_op (op: operation) (args: list mreg) (res: mreg) (k: code) :=
  match op, args with
  | Omove, a1 :: nil =>
      do r <- ireg_of res;
      do r1 <- ireg_of a1;
      OK (Palu MOV warchi r (inl r1) :: k)

  | Ointconst n, nil =>
      do r <- ireg_of res;
      OK (Palu MOV W32 r (inr  n) :: k)

  | Olongconst n, nil =>
      do r <- ireg_of res;
        OK ((Pmov r n) :: k)
  | Oaddrstack n, nil =>
      do r <- ireg_of res;
      addptrofs r SP n k

  | Oadd, a1 :: a2 :: nil =>
      assertion_str ["Oadd"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu ADD W32 r (inl r2) :: k)

  | Oaddimm n, a1 :: nil =>
      assertion_str ["Oaddimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu ADD W32 r (inr  n) :: k)

  | Oneg, a1 :: nil =>
      assertion_str ["Oneg"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu NEG W32 r (inl r) :: k)

  | Osub, a1 :: a2 :: nil =>
      assertion_str ["Osub"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu SUB W32 r (inl r2) :: k)

  | Osubimm n, a1 :: nil =>
      assertion_str ["Osubimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu SUB W32 r (inr n) :: k)

  | Omul, a1 :: a2 :: nil =>
      assertion_str ["Omul"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu MUL W32 r (inl r2) :: k)

  | Omulimm n, a1 :: nil =>
      assertion_str ["Omulimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu MUL W32 r (inr n) :: k)

  | Odivu, a1 :: a2 :: nil =>
      assertion_str ["Odivu"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu DIV W32 r (inl r2) :: k)

  | Odivuimm n, a1 :: nil =>
      assertion_str ["Odivuimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu DIV W32 r (inr n) :: k)

  | Omodu, a1 :: a2 :: nil =>
      assertion_str ["Omodu"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu MOD W32 r (inl r2) :: k)

  | Omoduimm n, a1 :: nil =>
      assertion_str ["Omoduimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu MOD W32 r (inr n) :: k)

  | Oand, a1 :: a2 :: nil =>
      assertion_str ["Oand"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu AND W32 r (inl r2) :: k)

  | Oandimm n, a1 :: nil =>
      assertion_str ["Oandimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu AND W32 r (inr n) :: k)

  | Oor, a1 :: a2 :: nil =>
      assertion_str ["Oor"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu OR W32 r (inl r2) :: k)

  | Oorimm n, a1 :: nil =>
      assertion_str ["Oorimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu OR W32 r (inr n) :: k)

  | Oxor, a1 :: a2 :: nil =>
      assertion_str ["Oxor"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu XOR W32 r (inl r2) :: k)

  | Oxorimm n, a1 :: nil =>
      assertion_str ["Oxorimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu XOR W32 r (inr n) :: k)

  | Oshl, a1 :: a2 :: nil =>
      assertion_str ["Oshl"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu LSH W32 r (inl r2) :: k)

  | Oshlimm n, a1 :: nil =>
      assertion_str ["Oshlimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu LSH W32 r (inr n) :: k)

  | Oshr, a1 :: a2 :: nil =>
      assertion_str ["Oshr"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu ARSH W32 r (inl r2) :: k)

  | Oshrimm n, a1 :: nil =>
      assertion_str ["Oshrimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu ARSH W32 r (inr n) :: k)

  | Oshru, a1 :: a2 :: nil =>
      assertion_str ["Oshru"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu RSH W32 r (inl r2) :: k)

  | Oshruimm n, a1 :: nil =>
      assertion_str ["Oshruimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu RSH W32 r (inr n) :: k)

  | Ocmp cmp, _ =>
      transl_cond_op cmp res args k

| Oaddrsymbol s ofs, nil =>
    do r <- ireg_of res;
      OK (Ploadsymbol r s ofs :: k)

| Ocast8signed, a1 :: nil =>
    do r <- ireg_of res;
    assertion_str ["Ocast8signed"] (mreg_eq a1 res);
OK (Palu LSH W32 r (inr (Int.repr 24)) ::
      Palu ARSH W32 r (inr (Int.repr 24)) :: k)
| Ocast16signed, a1 :: nil =>
    do r <- ireg_of res;
    assertion_str ["Ocast16signed"] (mreg_eq a1 res);
OK (Palu LSH W32 r (inr (Int.repr 16)) ::
      Palu ARSH W32 r (inr (Int.repr 16)) :: k)
| Ocast32unsigned, a1 :: nil =>
    do r <- ireg_of res;
    assertion_str ["Ocast32unsigned"] (mreg_eq a1 res);
    OK (Palu (CONV DWOFW) W64 r (inr Int.zero) :: k)
| Ocast32signed, a1 :: nil =>
    do r <- ireg_of res;
    assertion_str ["Ocast32unsigned"] (mreg_eq a1 res);
OK (Palu (CONV DWOFW) W64 r (inr Int.zero) :: (Palu LSH W64 r (inr (Int.repr 32))) ::
      Palu ARSH W64 r (inr (Int.repr 32)) :: k)
| Olowlong, a1 :: nil =>
    do r <- ireg_of res;
    assertion_str ["Olowlong"] (mreg_eq a1 res);
OK (Palu (CONV WOFDW) W64 r (inr Int.zero)  :: k)
| Ohighlong, a1 :: nil =>
    do r <- ireg_of res;
    assertion_str ["Olowlong"] (mreg_eq a1 res);
  OK (Palu ARSH W64 r (inr (Int.repr 32)) :: (Palu (CONV WOFDW) W64 r (inr Int.zero))  :: k)

| Omod, a1 :: a2 :: nil => Error (msg "signed modulo is not available in eBPF")

| Oaddl , a1 ::a2 ::nil =>
    assertion_str ["Oaddl"] (mreg_eq a1 res);
    do r <- ireg_of res;
    do r2 <- ireg_of a2;
    OK (Palu ADD W64 r (inl r2) :: k)
| Oaddlimm n , a1 :: nil =>
    assertion_str ["Oaddlimm"] (mreg_eq a1 res);
    do r <- ireg_of res;
    do i <- get_int n ;
    OK (Palu ADD W64 r (inr i) :: k)
| Onegl , a1:: nil =>
    assertion_str ["Onegl"] (mreg_eq a1 res);
    do r <- ireg_of res;
    OK (Palu NEG W64 r (inl r) :: k)

| Osubl , a1 ::a2 ::nil =>
    assertion_str ["Osubl"] (mreg_eq a1 res);
    do r <- ireg_of res;
    do r2 <- ireg_of a2;
    OK (Palu SUB W64 r (inl r2) :: k)

| Osublimm n , a1::nil =>
    assertion_str ["Osublimm"] (mreg_eq a1 res);
    do r <- ireg_of res;
    do i <- get_int n;
    OK (Palu SUB W64 r (inr i) :: k)

| Omull  , a1 :: a2 :: nil =>
    assertion_str ["Omull"] (mreg_eq a1 res);
    do r <- ireg_of res;
    do r2 <- ireg_of a2;
    OK (Palu MUL W64 r (inl r2) :: k)

| Omullimm n , a1::nil =>
    assertion_str ["Omullimm"] (mreg_eq a1 res);
    do r <- ireg_of res;
    do i <- get_int n ;
    OK (Palu MUL W64 r (inr i) :: k)

| Odivlu,  a1 :: a2 :: nil =>
      assertion_str ["Odivlu"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu DIV W64 r (inl r2) :: k)

| Odivluimm  n, a1 :: nil =>
      assertion_str ["Odivluimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do i <- get_int n;
      OK (Palu DIV W64 r (inr i) :: k)

| Omodlu, a1 :: a2 :: nil =>
      assertion_str ["Omodlu"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu MOD W64 r (inl r2) :: k)

| Omodluimm  n, a1 :: nil =>
      assertion_str ["Omodluimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do i <- get_int n ;
      OK (Palu MOD W64 r (inr i) :: k)

| Oandl, a1 :: a2 :: nil =>
      assertion_str ["Oandl"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu AND W64 r (inl r2) :: k)

| Oandlimm n, a1 :: nil =>
      assertion_str ["Oandlimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do i <- get_int n ;
      OK (Palu AND W64 r (inr i) :: k)

| Oorl, a1 :: a2 :: nil =>
      assertion_str ["Oorl"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu OR W64 r (inl r2) :: k)

  | Oorlimm n, a1 :: nil =>
      assertion_str ["Oorlimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do i <- get_int n ;
      OK (Palu OR W64 r (inr i) :: k)

| Oxorl, a1 :: a2 :: nil =>
      assertion_str ["Oxorl"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu XOR W64 r (inl r2) :: k)

  | Oxorlimm n, a1 :: nil =>
      assertion_str ["Oxorlimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do i <- get_int n ;
      OK (Palu XOR W64 r (inr i) :: k)

  | Oshll, a1 :: a2 :: nil =>
      assertion_str ["Oshll"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu LSH W64 r (inl r2) :: k)

  | Oshllimm n, a1 :: nil =>
      assertion_str ["Oshllimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu LSH W64 r (inr n) :: k)

  | Oshrl, a1 :: a2 :: nil =>
      assertion_str ["Oshrl"] (mreg_eq a1 res);
      do r <- ireg_of res;
      do r2 <- ireg_of a2;
      OK (Palu ARSH W64 r (inl r2) :: k)

  | Oshrlimm n, a1 :: nil =>
      assertion_str ["Oshrlimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu ARSH W64 r (inr n) :: k)
  | Oshrluimm n, a1 :: nil =>
      assertion_str ["Oshrluimm"] (mreg_eq a1 res);
      do r <- ireg_of res;
      OK (Palu RSH W64 r (inr n) :: k)

(* (a1 <> a2 or should destroy a temp register?

  | Omakelong, a1::a2::nil =>
    assertion_str ["Omakelong"] (mreg_eq a1 res);
    do r1 <- ireg_of a1;
    do r2 <- ireg_of a2;
    OK (Palu LSHW W32 r1 (inr (Imm32 (Int.repr 32))) ::
             Palu ADDW W64 r1 (inl r2) :: k) *)
| Oshrlu      , _
| Oshrluimm _ , _ => Error (MSG "ebpf(64) does not support '" :: MSG (string_of_operation op) :: MSG "'" :: nil)

| Ofloatconst _, _
| Osingleconst _, nil

| Onegf, _
| Oabsf, _
| Oaddf, _
| Osubf, _
| Omulf, _
| Odivf, _

| Onegfs, _
| Oabsfs, _
| Oaddfs, _
| Osubfs, _
| Omulfs, _
| Odivfs, _

| Osingleoffloat, _
| Ofloatofsingle, _

| Ointoffloat, _
| Ointuoffloat, _
| Ofloatofint, _
| Ofloatofintu, _
| Ointofsingle, _
| Ointuofsingle, _
| Osingleofint, _
| Osingleofintu, _

| Olongoffloat, _
| Olonguoffloat, _
| Ofloatoflong, _
| Ofloatoflongu, _
| Olongofsingle, _
| Olonguofsingle, _
| Osingleoflong, _
| Osingleoflongu, _ => Error (msg "Floating point conversions are not available in eBPF")
| o, _ => Error (MSG "Asmgen.transl_op "::MSG (string_of_operation o):: MSG " is not supported" :: nil)
  end.



(** Accessing data in the stack frame. *)


Definition transl_typ (t: typ): res (sizeOp) :=
  match t with
  | Tany32 => OK WordAny
  | Tint => OK Word
  | Tsingle | Tfloat => Error (msg "Floating point types are not available in eBPF")
  | Tlong => if Archi.ptr64 then OK DBWord else Error (msg "Tlong is only available for eBPF-64")
  | Tany64 => if Archi.ptr64 then OK DBWordAny else Error (msg "Tany64 is only available for eBPF-64")
  end.


(** Translation of memory accesses: loads, and stores. *)

Definition loadind (base: ireg) (ofs: ptrofs) (ty: typ) (dst: mreg) (k: code): res (list instruction) :=
  do r <- ireg_of dst;
  do size <- transl_typ ty;
  OK (Pload size r base ofs :: k).

Definition loadind_ptr (base: ireg) (ofs:ptrofs) (dst:ireg) (k:code) :=
  Pload (if Archi.ptr64 then DBWord else Word) dst base ofs  :: k.


Definition storeind (base: ireg) (ofs: ptrofs) (ty: typ) (src: mreg) (k: code): res (list instruction) :=
  do r <- ireg_of src;
  do size <- transl_typ ty;
  OK (Pstore size base (inl r) ofs :: k).

Definition transl_load_indexed_in_range (chunk : memory_chunk) (d:ireg) (a:ireg) (ofs: ptrofs) (k:code) : res (list instruction) :=
      match chunk with
      | Mbool          => OK (Pload Byte d a ofs :: k)
      | Mint8unsigned  => OK (Pload Byte d a ofs :: k)
      | Mint16unsigned => OK (Pload HalfWord d a ofs :: k)
      | Many32         => OK (Pload WordAny d a ofs :: k)
      | Mint32         => OK (Pload Word   d a ofs :: k)
      | Mint64         => if Archi.ptr64 then OK (Pload DBWord d a ofs :: k) else Error (msg "int64 is only available for eBPF-64")
      | Many64         => if Archi.ptr64 then OK (Pload DBWordAny d a ofs :: k) else Error (msg "int64 is only available for eBPF-64")
      | Mint8signed    => OK (Pload Byte d a ofs :: Palu LSH W32 d (inr (Int.repr 24)) :: Palu ARSH W32 d (inr (Int.repr 24)) :: k)
      | Mint16signed   => OK (Pload HalfWord d a ofs :: Palu LSH W32 d (inr (Int.repr 16)) :: Palu ARSH W32 d (inr (Int.repr 16)) :: k)
      | Mfloat32 | Mfloat64      => Error (msg "Floating point numbers are not supported by eBPF")
      end.

Definition transl_load_indexed (chunk : memory_chunk) (d:ireg) (a:ireg) (ofs: ptrofs) (k:code) : res (list instruction) :=
  if Size.Ptrofs.is_16_signed ofs
  then transl_load_indexed_in_range chunk d a ofs k
  else
    if Size.Ptrofs.is_int ofs
    then 
      do c <- transl_load_indexed_in_range chunk d d Ptrofs.zero k ;
      OK (Palu MOV warchi d (inl a) :: Palu ADD warchi d (inr (Ptrofs.to_int ofs)) :: c)
    else Error (MSG "Offset ":: errcode_of_Z (Ptrofs.signed ofs) ++ MSG " is not representable"::nil).



Definition transl_load (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (dst: mreg) (k: code): res (list instruction) :=
  match addr, args with
  | Aindexed ofs, a1 :: nil =>
      do r <- ireg_of dst;
      do r1 <- ireg_of a1;
      transl_load_indexed chunk r r1 ofs k

  | Ainstack ofs, nil =>
      do r <- ireg_of dst;
      transl_load_indexed chunk r SP ofs k
  | _, _ => Error(msg "Asmgen.transl_load")
  end.

Definition transl_store_indexed_in_range (chunk : memory_chunk) (d:ireg) (ofs: ptrofs) (a:ireg)  (k:code) : res (list instruction) :=
  match chunk with
  | Mbool          => OK (Pstore Byte d (inl a) ofs :: k)
  | Mint8unsigned  => OK (Pstore Byte d (inl a) ofs :: k)
  | Mint16unsigned => OK (Pstore HalfWord d (inl a) ofs :: k)
  | Many32         => OK (Pstore WordAny d (inl a) ofs :: k)
  | Mint32         => OK (Pstore Word   d (inl a) ofs :: k)
  | Mint64         => if Archi.ptr64 then OK (Pstore DBWord d (inl a) ofs :: k) else Error (msg "int64 is only available for eBPF-64")
  | Many64         => if Archi.ptr64 then OK (Pstore DBWordAny d (inl a) ofs :: k) else Error (msg "int64 is only available for eBPF-64")
  | Mint8signed    => OK (Pstore Byte d (inl a) ofs :: k)
  | Mint16signed   => OK (Pstore HalfWord d (inl a) ofs  :: k)
  | Mfloat32 | Mfloat64      => Error (msg "Floating point numbers are not supported by eBPF")
  end.

Definition transl_store_indexed (chunk : memory_chunk) (d:ireg) (ofs: ptrofs) (a:ireg)  (k:code) : res (list instruction) :=
  if Size.Ptrofs.is_16_signed ofs
  then transl_store_indexed_in_range chunk d ofs a  k
  else Error (MSG "Offset " :: errcode_of_Z (Ptrofs.signed ofs) ++ MSG " is not representable"::nil).


Definition transl_store (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (src: mreg) (k: code): res (list instruction) :=
  match addr, args with
  | Aindexed ofs, a1 :: nil =>
      do r <- ireg_of src;
      do r1 <- ireg_of a1;
      (transl_store_indexed chunk r1 ofs r  k)

  | Ainstack ofs, nil =>
      do r <- ireg_of src;
       (transl_store_indexed chunk SP ofs r  k)

  | _, _ => Error(msg "Asmgen.transl_store")
  end.

(** Translation of a Mach instruction. *)
Definition name_of_builtin (ef:external_function) : string :=
  match ef with
    EF_external s _ => append "external " s
  | EF_builtin s  _  => append "builtin " s
  | EF_runtime s _  => append "runtime " s
  | EF_vload  _    => "vload"
  | EF_vstore _    => "vstore"
  | EF_malloc      => "malloc"
  | EF_free        => "free"
  | EF_memcpy _ _  => "memcpy"
  | EF_annot _ _ _ => "annot"
  | EF_annot_val _ _ _ => "annot_val"
  | EF_inline_asm s _ _ => append "inline_adm " s
  | EF_debug _ _ _      => "debug"
  end.

Definition transl_instr (f: Mach.function) (i: Mach.instruction)
                        (ep: bool) (k: code): res (list instruction) :=
  match i with
  | Mgetstack ofs ty dst => loadind SP ofs ty dst k

  | Msetstack src ofs ty => storeind SP ofs ty src k

  | Mgetparam ofs ty dst =>
      do c <- loadind R0 ofs ty dst k;
      OK (if ep then c
                else loadind_ptr SP f.(fn_link_ofs) R0 c)
  | Mop op args res => transl_op op args res k

  | Mload chunk addr args dst => transl_load chunk addr args dst k

  | Mstore chunk addr args src => transl_store chunk addr args src k

  | Mcall sig (inr symb) => OK (Pcall (inr symb) sig :: k)
  | Mcall sig (inl r) => do r1 <- ireg_of r ; OK (Pcall (inl r1) sig :: k)

  | Mtailcall sig (inr symb) =>
      OK (Pfreeframe f.(fn_stacksize) f.(fn_retaddr_ofs) f.(fn_link_ofs) :: Pjmp (inr symb) :: k)

  | Mtailcall sig (inl r) => Error (msg "Indirect (tail) calls are not implemented")

  | Mbuiltin ef args res => Error (MSG "Builtin ":: MSG (name_of_builtin ef) :: MSG " is not supported by eBPF"::nil)

  | Mlabel lbl => OK (Plabel lbl :: k)

  | Mgoto lbl => OK (Pjmp (inl lbl) :: k)

  | Mcond cond args lbl => transl_cbranch cond args lbl k

  | Mjumptable arg tbl => Error (msg "Jump tables are not supported by eBPF: pass -fno-jumptables ")

  | Mreturn => OK (Pfreeframe f.(fn_stacksize) f.(fn_retaddr_ofs) f.(fn_link_ofs) :: Pret :: k)
  end.

(** Translation of a code sequence *)

Definition it1_is_parent (before: bool) (i: Mach.instruction) : bool :=
  match i with
  | Msetstack src ofs ty => before
  | Mgetparam ofs ty dst => negb (mreg_eq dst I0)
  | Mop op args res => before && negb (mreg_eq res I0)
  | _ => false
  end.

(** This is the naive definition that we no longer use because it
  is not tail-recursive.  It is kept as specification. *)

Fixpoint transl_code (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  match il with
  | nil => OK nil
  | i1 :: il' =>
      do k <- transl_code f il' (it1_is_parent it1p i1);
      transl_instr f i1 it1p k
  end.

(** This is an equivalent definition in continuation-passing style
  that runs in constant stack space. *)

Fixpoint transl_code_rec (f: Mach.function) (il: list Mach.instruction)
                         (it1p: bool) (k: code -> res code) :=
  match il with
  | nil => k nil
  | i1 :: il' =>
      transl_code_rec f il' (it1_is_parent it1p i1)
        (fun c1 => do c2 <- transl_instr f i1 it1p c1; k c2)
  end.

Definition transl_code' (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  transl_code_rec f il it1p (fun c => OK c).

(** Translation of a whole function.  Note that we must check
  that the generated code contains less than [2^32] instructions,
  otherwise the offset part of the [PC] code pointer could wrap
  around, leading to incorrect executions. *)

Definition transl_function (f: Mach.function) :=
  do c <- transl_code' f f.(Mach.fn_code) true;
  OK (mkfunction f.(Mach.fn_sig)
    (Pallocframe f.(fn_stacksize) f.(fn_retaddr_ofs) f.(fn_link_ofs) :: c)).

Definition transf_function (f: Mach.function) : res Asm.function :=
  do tf <- transl_function f;
  if zlt Ptrofs.max_unsigned (list_length_z tf.(fn_code))
  then Error (msg "code size exceeded")
  else OK tf.

Definition transf_fundef (f: Mach.fundef) : res Asm.fundef :=
  transf_partial_fundef transf_function f.

Definition transf_program (p: Mach.program) : res Asm.program :=
  transform_partial_program transf_fundef p.
